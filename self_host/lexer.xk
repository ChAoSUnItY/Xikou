pub class Lexer {
    priv source: java::lang::String;
    priv mut pos: i32 = 0;
    priv mut currentToken: Token = null;
}

impl Lexer {
    pub self(source: java::lang::String) {
        self.source = source;
    }
    
    priv fn isWhitespace(ch: char) -> bool {
        return java::lang::Character.isWhitespace(ch);
    }

    priv fn isNumeric(ch: char) -> bool {
        return java::lang::Character.isDigit(ch);
    }
    
    priv fn isIdentStart(ch: char) -> bool {
        return java::lang::Character.isAlphabetic(ch as i32) || ch == '_';
    }
    
    priv fn isIdent(ch: char) -> bool {
        return isNumeric(ch) || isIdentStart(ch);
    }
    
    priv fn readChar(self, offset: i32) {
      self.pos += offset;
    }
    
    priv fn peekChar(self, offset: i32) -> char {
      if self.pos + offset >= self.source.length() {
        return '\0';
      }
      
      return self.source.charAt(self.pos + offset);
    }
    
    priv fn skipWhitespaces(self) {
      while isWhitespace(self.peekChar(0)) {
        self.readChar(1);
      }
    }
    
    priv fn nextToken(self) -> Token {
      self.skipWhitespaces();
      let ch = self.peekChar(0);
      
      if ch == '(' {
        self.readChar(1);
        return Token.self(TokenType.OpenParenthesis, "(");
      }
      
      if ch == ')' {
        self.readChar(1);
        return Token.self(TokenType.CloseParenthesis, ")");
      }

      if isIdentStart(ch) {
        let mut length = 1;

        while isIdent(ch) {
          length += 1;
        }

        let literal = self.source.substring(self.pos, self.pos + length);

        self.readChar(length);
        return Token.self(TokenType.Identifier, literal);
      }

      if isNumeric(ch) {
        let mut length = 1;

        while isNumeric(self.peekChar(length)) {
          length += 1;
        }

        let token = Token.self(TokenType.NumberLiteral, self.source.substring(self.pos, self.pos + length));
        self.readChar(length);
        return token;
      }
      
      if ch == '\0' {
        self.readChar(1);
        return Token.self(TokenType.EOF, "\0");
      }
      
      return null;
    }
    
    pub fn main(args: [java::lang::String]) {
      let lexer = Lexer.self("(4142))1231)\0");
      let mut token = lexer.nextToken();
      
      while token.type != TokenType.EOF {
        java::lang::System.out.println(token.type);
        token = lexer.nextToken();
      }
    }
}

pub class Token {
    pub type: TokenType;
    pub literal: java::lang::String;
}

impl Token {
    pub self(type: TokenType, literal: java::lang::String) {
        self.type = type;
        self.literal = literal;
    }
}

pub enum TokenType {
    CharLiteral,
    StringLiteral,
    NumberLiteral,
    Identifier,
    OpenParenthesis,
    CloseParenthesis,
    OpenBrace,
    CloseBrace,
    Dot,
    Comma,
    SemiColon,
    Colon,
    DoubleColon,
    Equal,
    Pub,
    Priv,
    Mut,
    Pkg,
    Class,
    Enum,
    Fn,
    Const,
    Let,
    Self,
    Impl,
    EOF
}
